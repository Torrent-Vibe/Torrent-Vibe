name: ðŸš€ Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      build_macos:
        type: boolean
        description: 'Build for macOS'
        default: true
      build_ubuntu:
        type: boolean
        description: 'Build for Ubuntu Linux'
        default: true
      build_windows:
        type: boolean
        description: 'Build for Windows'
        default: false
      build_web:
        type: boolean
        description: 'Build Web version'
        default: true

# https://docs.github.com/en/enterprise-cloud@latest/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-build
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' && github.ref != 'refs/heads/dev' }}
env:
  NODE_OPTIONS: --max-old-space-size=8192
  PRIVATE_REPO_GH_TOKEN: ${{ secrets.PRIVATE_REPO_GH_TOKEN }}
  PRIVATE_REPO: Innei/Torrent-Vibe-Private
  PUBLIC_REPO: Torrent-Vibe/Torrent-Vibe

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      platforms: ${{ steps.parse-platforms.outputs.platforms }}
      tag_name: ${{ steps.compute-tag.outputs.tag_name }}
    steps:
      - name: Parse platforms input
        id: parse-platforms
        run: |
          # Collect selected platforms based on boolean inputs
          platforms=""

          if [ "${{ github.event.inputs.build_macos }}" = "true" ]; then
            platforms="$platforms\"macos-latest\","
          fi

          if [ "${{ github.event.inputs.build_ubuntu }}" = "true" ]; then
            platforms="$platforms\"ubuntu-latest\","
          fi

          if [ "${{ github.event.inputs.build_windows }}" = "true" ]; then
            platforms="$platforms\"windows-latest\","
          fi

          # Remove trailing comma and wrap in brackets
          platforms_json="[${platforms%,}]"

          echo "platforms=$platforms_json" >> $GITHUB_OUTPUT
          echo "Parsed platforms: $platforms_json"

      - name: Compute tag name
        id: compute-tag
        run: |
          UTC_TAG=$(date -u +%Y%m%d%H%M%S)
          TAG_NAME="v$UTC_TAG"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Computed tag: $TAG_NAME"

  release:
    needs: setup
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: ${{ fromJSON(needs.setup.outputs.platforms) }}
        exclude:
          - os: ${{ github.event.inputs.store == 'true' && 'ubuntu-latest' }}

    permissions:
      id-token: write
      contents: write

    steps:
      - name: Check out Git repository Fully
        uses: actions/checkout@v5

        with:
          fetch-depth: 1
          lfs: true
          repository: ${{ env.PRIVATE_REPO }}
          token: ${{ env.PRIVATE_REPO_GH_TOKEN }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'pnpm'

      - name: Install Python setuptools
        if: runner.os == 'macOS'
        run: brew install python-setuptools

      - name: Install appdmg
        if: runner.os == 'macOS'
        run: pnpm add -g appdmg

      - name: Install dependencies
        run: pnpm i

      - name: Build - Secure (Windows/Linux)
        if: runner.os == 'Linux' || runner.os == 'Windows'
        run: pnpm electron:build:secure
        env:
          APP_VERSION: ${{ needs.setup.outputs.tag_name }}

      - name: Build - macOS (secure, dual-arch)
        if: runner.os == 'macOS'
        run: |
          pnpm run preelectron:build:secure || true
          SECURITY_OBFUSCATION=1 APP_VERSION=${{ needs.setup.outputs.tag_name }} npx electron-vite build
          SECURITY_OBFUSCATION=1 APP_VERSION=${{ needs.setup.outputs.tag_name }} npx electron-forge make --arch=x64 --platform=darwin
          SECURITY_OBFUSCATION=1 APP_VERSION=${{ needs.setup.outputs.tag_name }} npx electron-forge make --arch=arm64 --platform=darwin
          node scripts/verify-build-integrity.js
        env:
          APP_VERSION: ${{ needs.setup.outputs.tag_name }}

      - name: Notarize & staple macOS app (dual-arch)
        if: runner.os == 'macOS'
        timeout-minutes: 10
        env:
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          ARM64_ZIP=$(find out/make -type f -name "*-macos-arm64.zip" -print -quit)
          X64_ZIP=$(find out/make -type f -name "*-macos-x64.zip" -print -quit)
          echo "[i] macOS artifacts: arm64=$ARM64_ZIP x64=$X64_ZIP"
          if [ -z "$ARM64_ZIP" ] || [ -z "$X64_ZIP" ]; then
            echo "[-] Could not locate macOS zip artifacts in out/make" >&2
            find out/make -maxdepth 5 -type f -name "*.zip" -print || true
            exit 1
          fi
          ARM64_ZIP_ABS="$PWD/$ARM64_ZIP"
          X64_ZIP_ABS="$PWD/$X64_ZIP"
          RELEASE_DIR="$PWD/release"
          mkdir -p "$RELEASE_DIR"
          cd scripts/apple
          ./action.sh --import-arm64 "$ARM64_ZIP_ABS" --import-amd64 "$X64_ZIP_ABS" --export-dir "$RELEASE_DIR"
          rm -rf "$ARM64_ZIP_ABS"
          rm -rf "$X64_ZIP_ABS"
          rm -rf **/*.dmg

      - name: Rename macOS artifacts to versioned format
        if: runner.os == 'macOS'
        run: |
          # Function to convert version strings to A.B.C.D format
          convert_version() {
            local version="$1"
            # Remove leading 'v' if present
            version="${version#v}"

            # Check if it's already a dotted version (like 1.2.3)
            if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+ ]]; then
              # Split by dots and ensure 4 components
              IFS='.' read -ra VERSION_PARTS <<< "$version"
              printf "%d.%d.%d.%d" "${VERSION_PARTS[0]}" "${VERSION_PARTS[1]}" "${VERSION_PARTS[2]}" "${VERSION_PARTS[3]:-0}"
              return
            fi

            # Handle timestamp-style versions like 20250908155358
            if [[ "$version" =~ ^[0-9]{14}$ ]]; then
              local year="${version:0:4}"
              local month="${version:4:2}"
              local day="${version:6:2}"
              local hour="${version:8:2}"
              local minute="${version:10:2}"
              # Remove leading zeros from month and day
              month=$((10#$month))
              day=$((10#$day))
              # Combine hour and minute for the 4th component
              local time_component=$((10#$hour * 100 + 10#$minute))
              printf "%d.%d.%d.%d" "$year" "$month" "$day" "$time_component"
              return
            fi

            # Fallback: treat as single number
            printf "%d.0.0.0" "$version"
          }

          TAG_NAME="${{ needs.setup.outputs.tag_name }}"
          FILE_VERSION=$(convert_version "$TAG_NAME")

          echo "Tag name: $TAG_NAME"
          echo "File version: $FILE_VERSION"

          cd release

          # Rename arm64 artifact
          if [ -f "Torrent.Vibe-darwin-arm64.zip" ]; then
            mv "Torrent.Vibe-darwin-arm64.zip" "Torrent.Vibe-${FILE_VERSION}-darwin-arm64.zip"
            echo "Renamed Torrent.Vibe-darwin-arm64.zip -> Torrent.Vibe-${FILE_VERSION}-darwin-arm64.zip"
          fi

          # Rename x64 artifact
          if [ -f "Torrent.Vibe-darwin-x64.zip" ]; then
            mv "Torrent.Vibe-darwin-x64.zip" "Torrent.Vibe-${FILE_VERSION}-darwin-x64.zip"
            echo "Renamed Torrent.Vibe-darwin-x64.zip -> Torrent.Vibe-${FILE_VERSION}-darwin-x64.zip"
          fi

      - name: Prepare release files (Windows)
        if: runner.os == 'Windows'
        run: |
          New-Item -ItemType Directory -Force -Path release
          if (Test-Path "out/make") {
            Get-ChildItem -Path "out/make" -Recurse -Include "*.dmg","*.AppImage","*.exe","*.zip","*.yml" | Copy-Item -Destination "release/"
          }
        shell: pwsh

      - name: Prepare release files (Unix)
        if: runner.os != 'Windows'
        run: |
          mkdir -p release
          if [ -d "out/make" ]; then
            find out/make -type f \( -name "*.dmg" -o -name "*.AppImage" -o -name "*.exe" -o -name "*.zip" -o -name "*.yml" \) -exec cp {} release/ \;
          fi
        shell: bash

      - name: Refresh macOS updater metadata
        if: runner.os == 'macOS'
        run: |
          RELEASE_DIR="$PWD/release"
          ARM64_FINAL=$(find "$RELEASE_DIR" -maxdepth 1 -type f -name "*darwin-arm64*.zip" -print -quit)
          X64_FINAL=$(find "$RELEASE_DIR" -maxdepth 1 -type f -name "*darwin-x64*.zip" -print -quit)
          if [ -z "$ARM64_FINAL" ] || [ -z "$X64_FINAL" ]; then
            echo "[-] Failed to locate notarized macOS zips in $RELEASE_DIR" >&2
            find "$RELEASE_DIR" -maxdepth 1 -type f -name "*.zip" -print || true
            exit 1
          fi
          node scripts/generate-electron-metadata.js \
            --version "${{ needs.setup.outputs.tag_name }}" \
            --artifact "path=$ARM64_FINAL,platform=darwin,arch=arm64" \
            --artifact "path=$X64_FINAL,platform=darwin,arch=x64"

      - name: Generate app manifest (mainHash)
        shell: bash
        run: |
          node scripts/generate-app-build-manifest.js \
            --output release/manifest.yaml \
            --tag ${{ needs.setup.outputs.tag_name }}

      - name: Upload desktop artifacts to release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.setup.outputs.tag_name }}
          name: Release ${{ needs.setup.outputs.tag_name }}
          # generate_release_notes: ${{ matrix.os == 'macos-latest' }}
          generate_release_notes: false
          fail_on_unmatched_files: false
          append_body: true
          make_latest: ${{ matrix.os == 'macos-latest' }}
          files: |
            release/**/*

  build-web:
    needs: setup
    runs-on: ubuntu-latest
    if: github.event.inputs.build_web != 'false'

    permissions:
      contents: write

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
          repository: ${{ env.PRIVATE_REPO }}
          token: ${{ env.PRIVATE_REPO_GH_TOKEN }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm i

      - name: Build Web Production
        run: pnpm run build:production

      - name: Create web artifact archive
        run: |
          # Function to convert version strings to A.B.C.D format
          convert_version() {
            local version="$1"
            # Remove leading 'v' if present
            version="${version#v}"

            # Check if it's already a dotted version (like 1.2.3)
            if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+ ]]; then
              # Split by dots and ensure 4 components
              IFS='.' read -ra VERSION_PARTS <<< "$version"
              printf "%d.%d.%d.%d" "${VERSION_PARTS[0]}" "${VERSION_PARTS[1]}" "${VERSION_PARTS[2]}" "${VERSION_PARTS[3]:-0}"
              return
            fi

            # Handle timestamp-style versions like 20250908155358
            if [[ "$version" =~ ^[0-9]{14}$ ]]; then
              local year="${version:0:4}"
              local month="${version:4:2}"
              local day="${version:6:2}"
              local hour="${version:8:2}"
              local minute="${version:10:2}"
              # Remove leading zeros from month and day
              month=$((10#$month))
              day=$((10#$day))
              # Combine hour and minute for the 4th component
              local time_component=$((10#$hour * 100 + 10#$minute))
              printf "%d.%d.%d.%d" "$year" "$month" "$day" "$time_component"
              return
            fi

            # Fallback: treat as single number
            printf "%d.0.0.0" "$version"
          }

          TAG_NAME="${{ needs.setup.outputs.tag_name }}"
          FILE_VERSION=$(convert_version "$TAG_NAME")

          cd layer/renderer/dist
          mkdir -p public
          find . -maxdepth 1 -mindepth 1 ! -name public -exec mv {} public/ \;
          tar -czf "../../../Torrent.Vibe-${FILE_VERSION}-web.tar.gz" public/

      - name: Upload web artifacts to release
        uses: softprops/action-gh-release@v2
        with:
          repository: ${{ env.PUBLIC_REPO }}

          tag_name: ${{ needs.setup.outputs.tag_name }}
          name: Release ${{ needs.setup.outputs.tag_name }}
          generate_release_notes: false
          fail_on_unmatched_files: false
          append_body: true
          make_latest: false
          files: |
            Torrent.Vibe-*-web.tar.gz
